<script>
    // ===============================================================
    // 5. UI (Manipulaci√≥n del DOM)
    // ===============================================================

    /**
     * @description El objeto 'UI' agrupa todas las funciones responsables de manipular el DOM.
     */
    const UI = {
        // LOGICA DE foto de perfil
        /**
         * üÜï Actualiza la imagen de perfil del usuario con manejo robusto de errores.
         * @param {string} photoUrl - URL de la foto de perfil.
         * @param {string} email - Email del usuario (para fallback).
         */
        updateProfileImage(photoUrl, email) {
            const dropdownButton = document.querySelector('#dropdownUser1');
            const profileIcon = document.querySelector('#dropdownUser1 i.fas.fa-user-circle');

            if (!dropdownButton || !profileIcon) {
                console.warn('No se encontraron los elementos del perfil');
                return;
            }

            console.log('üñºÔ∏è Cargando imagen de perfil:', photoUrl);

            if (photoUrl) {
                // Remover imagen anterior si existe
                const existingImg = dropdownButton.querySelector('.profile-image');
                if (existingImg) existingImg.remove();

                // Crear nueva imagen
                const img = document.createElement('img');
                img.src = photoUrl;
                img.className = 'profile-image rounded-circle me-2';
                img.style.width = '32px';
                img.style.height = '32px';
                img.style.objectFit = 'cover';
                img.style.display = 'none'; // Ocultar hasta que cargue
                img.alt = 'Foto de perfil';

                // Manejar carga exitosa
                img.onload = function () {
                    console.log('‚úÖ Imagen de perfil cargada correctamente');
                    profileIcon.style.display = 'none';
                    this.style.display = 'inline';
                };

                // Manejar error de carga (aunque con Gravatar + fallback es muy raro)
                img.onerror = function () {
                    console.warn('‚ùå Error al cargar imagen, usando √≠cono por defecto');
                    this.remove();
                    profileIcon.style.display = 'inline';
                };

                // Timeout de seguridad
                setTimeout(() => {
                    if (img.style.display === 'none') {
                        console.warn('‚è∞ Timeout cargando imagen, usando √≠cono por defecto');
                        img.remove();
                        profileIcon.style.display = 'inline';
                    }
                }, 10000); // 10 segundos

                // Insertar imagen antes del √≠cono
                dropdownButton.insertBefore(img, profileIcon);
            } else {
                console.warn('No se proporcion√≥ URL de imagen');
                profileIcon.style.display = 'inline';
            }
        },

        /**
         * üÜï Muestra el nombre del superior del usuario en la barra superior.
         * @param {string} superiorName - El nombre del superior.
         */
        displayUserSuperior(superiorName) {
            const userSuperiorElement = document.getElementById('user-superior-display');
            if (userSuperiorElement) {
                userSuperiorElement.textContent = `Equipo: ${superiorName}`;
            }
        },
        // TERMINA LOGICA DE foto de perfil


        // LOGICA DE SUPERIOR
        /**
         * üÜï Muestra el nombre del superior del usuario en la barra superior.
         * @param {string} superiorName - El nombre del superior.
         */
        displayUserSuperior(superiorName) {
            const userSuperiorElement = document.getElementById('user-superior-display');
            if (userSuperiorElement) {
                userSuperiorElement.textContent = `Equipo: ${superiorName}`;
            }
        },
        // TERMINA LOGICA DE SUPERIOR

        // EMPIEZA IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        addChatMessage(sender, message) {
            const history = document.getElementById('chat-history');
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', sender);

            const p = document.createElement('p');
            p.textContent = message; // Usar textContent para prevenir inyecci√≥n de HTML
            messageDiv.appendChild(p);

            history.appendChild(messageDiv);
            history.scrollTop = history.scrollHeight;
        },

        showBotTyping(isLoading) {
            let typingIndicator = document.getElementById('bot-typing-indicator');
            if (isLoading) {
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.id = 'bot-typing-indicator';
                    typingIndicator.classList.add('chat-message', 'bot', 'bot-typing');
                    typingIndicator.innerHTML = `<p>Sticket Pro Assistant est√° escribiendo...</p>`;
                    document.getElementById('chat-history').appendChild(typingIndicator);
                    document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
                }
            } else {
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }
        },
        // TERMINA  IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        /**
         * ‚úÖ [MODIFICADO] Renderiza los contadores de tickets por motivo de escalamiento.
         * @param {object} motivoEscalamientoCounts - Objeto con el conteo de tickets por motivo.
         * @param {string} targetId - El ID del elemento contenedor donde se renderizar√°.
         */
        renderMotivoEscalamientoCounters(motivoEscalamientoCounts, targetId = 'motivo-escalamiento-counters') {
            const container = document.getElementById(targetId);
            if (!container) return;

            const sortedMotivos = Object.entries(motivoEscalamientoCounts)
                .sort(([, countA], [, countB]) => countB - countA) // Ordenar de mayor a menor
                .slice(0, 5); // Mostrar los top 5

            let html = `
        <div class="card h-100 shadow-sm">
          <div class="card-header">
            <h6><i class="fas fa-tags me-2"></i>Top 5 Motivos de Escalamiento</h6>
          </div>
          <div class="card-body">
            <ul class="list-group list-group-flush">
      `;

            if (sortedMotivos.length === 0) {
                html += `<li class="list-group-item text-muted fst-italic">No hay datos de motivos de escalamiento.</li>`;
            } else {
                sortedMotivos.forEach(([motivo, count]) => {
                    html += `
            <li class="list-group-item d-flex justify-content-between align-items-center">
              ${motivo}
              <span class="badge bg-primary rounded-pill">${count}</span>
            </li>
          `;
                });
            }

            html += `
            </ul>
          </div>
        </div>
      `;
            container.innerHTML = html;
        },

        /**
         * @description Aplica permisos visuales basados en el rol del usuario.
         */
        applyPermissions() {
            const role = state.userProfile.role;
            if (role === 'SUPERUSER' || role === 'AUDITOR') {
                document.getElementById('nav-auditoria').style.display = 'block';
            } else {
                document.getElementById('nav-auditoria').style.display = 'none';
            }
            const exportButton = document.getElementById('export-to-excel-btn');
            if (exportButton) {
                if (role === 'SUPERUSER' || role === 'AUDITOR') {
                    exportButton.style.display = 'block';
                } else {
                    exportButton.style.display = 'none';
                }
            }
        },

        // üÜï NUEVA FUNCI√ìN:
        renderNotificationSummary() {
            const notificationContainer = document.getElementById('notification-summary');
            if (!notificationContainer) return;

            const totalUnread = state.notifications.length;
            const recentNotifications = state.notifications.slice(0, 3);

            let notificationsHtml = '';

            if (recentNotifications.length === 0) {
                notificationsHtml = `
                    <p class="text-muted fst-italic">No hay notificaciones recientes.</p>
                `;
            } else {
                notificationsHtml = `
                    <ul class="list-group list-group-flush">
                        ${recentNotifications.map(n => `
                            <li class="list-group-item d-flex justify-content-between align-items-start notification-item-dashboard"
                                data-notification-row="${n.row}" data-ticket-id="${n.ticketId || ''}" style="cursor: pointer;">
                                <div>
                                    <small class="fw-bold">${n.message}</small><br>
                                    <small class="text-muted">${new Date(n.timestamp).toLocaleString()}</small>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                `;
            }

            notificationContainer.innerHTML = `
                <div class="card h-100">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6><i class="fas fa-bell me-2"></i>Notificaciones Recientes</h6>
                        <span class="badge bg-danger rounded-pill">${totalUnread}</span>
                    </div>
                    <div class="card-body">
                        ${notificationsHtml}
                    </div>
                </div>
            `;

            document.querySelectorAll('.notification-item-dashboard').forEach(item => {
                item.addEventListener('click', Handlers.handleNotificationClick);
            });
        },

        /**
         * ‚úÖ [MODIFICADO] Renderiza el resumen de tickets urgentes en el dashboard.
         * @param {string} targetId - El ID del elemento contenedor donde se renderizar√°.
         */
        renderUrgentTicketsSummary(targetId = 'urgent-tickets-summary') {
            const urgentContainer = document.getElementById(targetId);
            if (!urgentContainer) return;

            const urgentTickets = state.allTicketsForStats.filter(t => t.prioridad === 'Urgente');
            const recentUrgentTickets = urgentTickets.sort((a, b) => b.timestamp - a.timestamp).slice(0, 3);

            if (recentUrgentTickets.length === 0) {
                urgentContainer.innerHTML = `
                    <div class="card h-100">
                        <div class="card-header">
                            <h6><i class="fas fa-exclamation-triangle me-2"></i>Tickets Urgentes</h6>
                        </div>
                        <div class="card-body d-flex align-items-center justify-content-center">
                            <p class="text-muted fst-italic">No hay tickets urgentes actualmente.</p>
                        </div>
                    </div>
                `;
                return;
            }

            urgentContainer.innerHTML = `
                <div class="card h-100">
                    <div class="card-header">
                        <h6><i class="fas fa-exclamation-triangle me-2"></i>Tickets Urgentes</h6>
                    </div>
                    <div class="card-body">
                        ${recentUrgentTickets.map(t => `
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <small><strong>${t.ticketInterno}:</strong> ${t.pedido}</small>
                                <small class="text-muted">${t.timestamp.toLocaleDateString()}</small>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        },


        /**
         * @description Renderiza el contenido completo de la vista del dashboard.
         * @param {Array<object>} tickets - El array de tickets del estado global.
         */
        renderDashboard(tickets) {
            const stats = state.allTicketsForStats.reduce((acc, t) => {
                if (['Registrado', 'En Progreso'].includes(t.estado)) acc.open++;
                if (t.estado === 'En Progreso') acc.pending++;
                if (t.estado === 'Resuelto') acc.resolved++;
                if (t.prioridad === 'Urgente') acc.urgent++;
                return acc;
            }, { open: 0, pending: 0, resolved: 0, urgent: 0 });

            this.renderStats(stats);
            this.renderRecentTickets(state.allTicketsForStats.slice(0, 5));

            const chartData = this.prepareDashboardCharts(state.allTicketsForStats);

            this.renderD3Chart('ticketsChart', chartData.activity, 'line', 'Actividad de Tickets');
            this.renderD3Chart('ticket-status-chart', chartData.ticketStatus, 'bar', 'Distribuci√≥n de Tickets por Estado');

            // ‚úÖ CAMBIO: Renderizar el gr√°fico de m√©tricas en tiempo real como L√çNEA
            this.renderD3Chart('realtime-metrics-chart', chartData.realtimeMetrics, 'line', 'Tickets Creados (√öltimas 24h)');

            this.renderNotificationSummary();
            this.renderUrgentTicketsSummary('urgent-tickets-summary');
            this.renderMotivoEscalamientoCounters(chartData.motivoEscalamientoCounts, 'motivo-escalamiento-counters');
        },

        /**
         * @description Prepara y estructura los datos de los tickets para ser consumidos por la librer√≠a de gr√°ficos D3.js.
         * @param {Array<object>} tickets - El array de tickets.
         * @returns {object} Un objeto con datos listos para los gr√°ficos de actividad y SLA.
         */
        prepareDashboardCharts(tickets) {
            const activityByDay = new Array(7).fill(0);
            const resolvedByDay = new Array(7).fill(0);
            tickets.forEach(t => {
                const dayOfWeek = t.timestamp.getDay();
                const adjustedDay = (dayOfWeek === 0) ? 6 : dayOfWeek - 1; // Lunes=0, Domingo=6
                activityByDay[adjustedDay]++;
                if (t.estado === 'Resuelto') {
                    resolvedByDay[adjustedDay]++;
                }
            });

            // Datos para el gr√°fico de estado (para barras)
            const statusCounts = tickets.reduce((acc, t) => {
                const status = t.estado || 'Registrado';
                acc[status] = (acc[status] || 0) + 1;
                return acc;
            }, { 'Registrado': 0, 'En Progreso': 0, 'Resuelto': 0, 'Cerrado': 0 });

            const statusLabels = Object.keys(statusCounts);
            const statusData = Object.values(statusCounts);
            const statusColors = statusLabels.map(status => {
                switch (status) {
                    case 'Registrado': return '#4a90e2';
                    case 'En Progreso': return '#f5a623';
                    case 'Resuelto': return '#50e3c2';
                    case 'Cerrado': return '#9b9b9b';
                    default: return '#cccccc';
                }
            });

            // Datos para el gr√°fico de tickets por herramienta (para barras)
            const toolCounts = tickets.reduce((acc, t) => {
                const tool = t.herramienta || 'Desconocida';
                acc[tool] = (acc[tool] || 0) + 1;
                return acc;
            }, {});
            const toolLabels = Object.keys(toolCounts);
            const toolData = Object.values(toolCounts);
            const toolColors = toolLabels.map((_, i) => `hsl(${i * 60}, 70%, 60%)`); // Colores din√°micos

            // üÜï Datos para el gr√°fico de m√©tricas en tiempo real (ejemplo: tickets creados por hora en las √∫ltimas 24h)
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            const hourlyCounts = new Array(24).fill(0);
            const hourlyLabels = Array.from({ length: 24 }, (_, i) => {
                const hour = (now.getHours() - 23 + i + 24) % 24; // √öltimas 24 horas
                return `${hour.toString().padStart(2, '0')}:00`;
            });

            tickets.forEach(t => {
                const timestamp = new Date(t.timestamp);
                if (timestamp >= oneDayAgo && timestamp <= now) {
                    const hourDiff = Math.floor((now.getTime() - timestamp.getTime()) / (60 * 60 * 1000));
                    if (hourDiff >= 0 && hourDiff < 24) {
                        hourlyCounts[23 - hourDiff]++; // Contar en la hora correcta
                    }
                }
            });

            // üÜï Datos para el contador de motivos de escalamiento
            const motivoEscalamientoCounts = tickets.reduce((acc, t) => {
                const motivo = t.pedido || 'Desconocido';
                acc[motivo] = (acc[motivo] || 0) + 1;
                return acc;
            }, {});


            return {
                activity: {
                    labels: ['Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b', 'Dom'],
                    datasets: [{
                        label: 'Nuevos',
                        data: activityByDay,
                        borderColor: 'var(--secondary-color)',
                        tension: 0.4,
                        fill: false,
                    }, {
                        label: 'Resueltos',
                        data: resolvedByDay,
                        borderColor: 'var(--success-color)',
                        tension: 0.4,
                        fill: false,
                    }]
                },
                ticketStatus: { // Para gr√°fico de barras
                    labels: statusLabels,
                    data: statusData,
                    backgroundColor: statusColors
                },
                ticketsByTool: { // Para gr√°fico de barras
                    labels: toolLabels,
                    data: toolData,
                    backgroundColor: toolColors
                },
                // ‚úÖ CAMBIO: Formato de datos para gr√°fico de L√çNEA
                realtimeMetrics: {
                    labels: hourlyLabels,
                    datasets: [{
                        label: 'Creados',
                        data: hourlyCounts,
                        borderColor: 'var(--info-color)',
                        tension: 0.4,
                        fill: false,
                    }]
                },
                motivoEscalamientoCounts: motivoEscalamientoCounts // Datos para contadores
            };
        },

        /**
         * @description Renderiza la tabla completa de tickets en la vista 'Tickets'.
         * @param {Array<object>} tickets - El array de tickets a mostrar.
         */
        renderTicketsPage(tickets) {
            const tbody = document.getElementById('all-tickets-table-body');
            if (!tbody) return;

            // Llenar filtros de motivo de escalamiento y creadores
            const motivoEscalamientoFilter = document.getElementById('tickets-filter-motivoEscalamiento'); // üÜï RENOMBRADO
            const createdByFilter = document.getElementById('tickets-filter-createdBy');
            const equipoFilter = document.getElementById('tickets-filter-equipo'); // üÜï NUEVO
            const priorityFilter = document.getElementById('tickets-filter-priority');

            if (motivoEscalamientoFilter && createdByFilter && priorityFilter) {
                const allMotivosEscalamiento = [...new Set(state.allTicketsForStats.map(t => t.pedido).filter(p => p && p.trim() !== ''))].sort();
                UI.populateSelect(motivoEscalamientoFilter, allMotivosEscalamiento, 'Filtrar por Motivo Escalamiento'); // üÜï RENOMBRADO

                UI.populateSelect(createdByFilter, state.allCreators, 'Filtrar por Creador');
                UI.populateSelect(equipoFilter, state.allSuperiores, 'Filtrar por Equipo'); // üÜï NUEVO

                // Restaurar valores de filtro
                motivoEscalamientoFilter.value = state.filters.motivoEscalamiento; // üÜï RENOMBRADO
                createdByFilter.value = state.filters.createdBy;
                equipoFilter.value = state.filters.equipo; // üÜï NUEVO
                document.getElementById('tickets-filter-status').value = state.filters.status;
                document.getElementById('tickets-filter-tool').value = state.filters.tool;
                document.getElementById('tickets-filter-startDate').value = state.filters.startDate;
                document.getElementById('tickets-filter-endDate').value = state.filters.endDate;
                priorityFilter.value = state.filters.priority;
            }

            if (tickets.length === 0) {
                tbody.innerHTML = `<td colspan="8" class="text-center text-muted fst-italic">No hay tickets para mostrar con los filtros actuales.</td>`;
            } else {
                tbody.innerHTML = tickets.map(t => `
                    <tr onclick="Handlers.handleTicketRowClick('${t.ticketInterno}')" style="cursor: pointer;">
                        <td>${t.ticketInterno}</td>
                        <td class="truncate-text" title="${t.pedido}">${t.pedido}</td>
                        <td class="truncate-text" title="${t.planilla}">${t.planilla}</td>
                        <td><span class="badge bg-secondary">${t.creadoPor}</span></td>
                        <td><span class="badge ${this.getBadgeClassForStatus(t.estado)}">${t.estado || 'N/A'}</span></td>
                        <td><span class="badge ${this.getBadgeClassForPriority(t.prioridad)}">${t.prioridad || 'Normal'}</span></td>
                        <td>${t.timestamp.toLocaleDateString()}</td>
                        <td>${t.herramienta || 'N/A'}</td>
                    </tr>`).join('');
            }
            this.renderPaginationControls();
        },

        /**
         * üÜï Funci√≥n de utilidad para obtener la clase CSS de Bootstrap correspondiente a una prioridad de ticket.
         * @param {string} priority - La prioridad del ticket.
         * @returns {string} La clase CSS de la insignia (badge).
         */
        getBadgeClassForPriority(priority) {
            switch (priority) {
                case 'Urgente': return 'bg-danger';
                case 'Normal': return 'bg-info';
                default: return 'bg-info';
            }
        },

        /**
         * @description Rellena un elemento select con opciones.
         * @param {HTMLElement} selectElement - El elemento select a poblar.
         * @param {Array<string>} optionsArray - Array de strings para las opciones.
         * @param {string} defaultOptionText - Texto para la opci√≥n por defecto.
         */
        populateSelect(selectElement, optionsArray, defaultOptionText) {
            const currentValue = selectElement.value;
            selectElement.innerHTML = `<option value="">${defaultOptionText}</option>`;
            optionsArray.forEach(option => {
                if (option) {
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    selectElement.appendChild(opt);
                }
            });
            if (currentValue && Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
                selectElement.value = currentValue;
            }
        },

        /**
         * üÜï Rellena el datalist para el campo "Motivo de Escalamiento".
         * @param {Array<string>} motivos - Array de strings con los motivos operativos.
         */
        populateMotivoEscalamientoDatalist(motivos) {
            const datalist = document.getElementById('motivoEscalamientoOptions');
            if (datalist) {
                datalist.innerHTML = '';
                motivos.forEach(motivo => {
                    const option = document.createElement('option');
                    option.value = motivo;
                    datalist.appendChild(option);
                });
            }
        },

        /**
         * @description Renderiza los controles de paginaci√≥n.
         */
        renderPaginationControls() {
            const paginationContainer = document.getElementById('tickets-pagination');
            if (!paginationContainer) return;

            const { currentPage, totalPages } = state.pagination;
            let paginationHtml = `
                <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="prev">Anterior</a>
                </li>
            `;

            let startPage = Math.max(1, currentPage - 2);
            let endPage = Math.min(totalPages, currentPage + 2);

            if (startPage === 1 && endPage < totalPages) {
                endPage = Math.min(totalPages, endPage + (3 - (currentPage - startPage)));
            }
            if (endPage === totalPages && startPage > 1) {
                startPage = Math.max(1, startPage - (3 - (endPage - currentPage)));
            }

            for (let i = startPage; i <= endPage; i++) {
                paginationHtml += `
                    <li class="page-item ${i === currentPage ? 'active' : ''}">
                        <a class="page-link" href="#" data-page="${i}">${i}</a>
                    </li>
                `;
            }

            paginationHtml += `
                <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="next">Siguiente</a>
                </li>
            `;
            paginationContainer.innerHTML = paginationHtml;
        },

        /**
         * @description Renderiza el contenido de la p√°gina de reportes.
         * @param {Array<object>} tickets - El array de tickets.
         */
        renderReportsPage(tickets) {
            const chartData = this.prepareDashboardCharts(state.allTicketsForStats);
            this.renderD3Chart('reportsChart1', chartData.activity, 'line', 'Tendencia de Tickets');
            this.renderD3Chart('reportsChart3', chartData.ticketsByTool, 'bar', 'Tickets por Herramienta');
        },

        /**
         * @description Actualiza los contadores de estad√≠sticas en el dashboard.
         * @param {object} stats - Objeto con las estad√≠sticas calculadas.
         */
        renderStats(stats) {
            document.getElementById('stats-open').textContent = stats.open;
            document.getElementById('stats-pending').textContent = stats.pending;
            document.getElementById('stats-resolved').textContent = stats.resolved;
            document.getElementById('stats-urgent').textContent = stats.urgent;
        },

        /**
         * @description Renderiza la tabla de tickets recientes en el dashboard.
         * @param {Array<object>} tickets - Array de los tickets m√°s recientes.
         */
        renderRecentTickets(tickets) {
            const tbody = document.getElementById('recent-tickets-body');
            if (!tbody) return;
            if (tickets.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center text-muted fst-italic">No hay tickets recientes.</td></tr>`;
                return;
            }
            tbody.innerHTML = tickets.map(t => `
        <tr onclick="Handlers.handleTicketRowClick('${t.ticketInterno}')" style="cursor:pointer;">
            <td>${t.ticketInterno}</td>
            <td class="truncate-text" title="${t.pedido}">${t.pedido}</td>
            <td class="truncate-text" title="${t.planilla}">${t.planilla}</td>
            <td><span class="badge bg-secondary">${t.creadoPor}</span></td>
            <td><span class="badge ${this.getBadgeClassForStatus(t.estado)}">${t.estado}</span></td>
            <td>${t.timestamp.toLocaleDateString()}</td>
        </tr>`).join('');
        },

        /**
         * üÜï Renderiza el Panel de Gesti√≥n R√°pida de Tickets.
         */
        renderQuickManagePanel() {
            const tbody = document.getElementById('quick-manage-tickets-table-body');
            if (!tbody) return;

            let filteredTickets = state.allTicketsForStats;

            if (state.quickManageFilters.status) {
                filteredTickets = filteredTickets.filter(t => t.estado === state.quickManageFilters.status);
            }
            if (state.quickManageFilters.priority) {
                filteredTickets = filteredTickets.filter(t => t.prioridad === state.quickManageFilters.priority);
            }

            filteredTickets.sort((a, b) => b.timestamp - a.timestamp);

            state.quickManagePagination.totalTickets = filteredTickets.length;
            state.quickManagePagination.totalPages = Math.ceil(state.quickManagePagination.totalTickets / state.quickManagePagination.pageSize);

            const { currentPage, pageSize } = state.quickManagePagination;
            const startIndex = (currentPage - 1) * pageSize;
            const paginatedTickets = filteredTickets.slice(startIndex, startIndex + pageSize);

            if (paginatedTickets.length === 0) {
                tbody.innerHTML = `<tr><td colspan="8" class="text-center text-muted fst-italic">No hay tickets para gestionar con los filtros actuales.</td></tr>`;
            } else {
                tbody.innerHTML = paginatedTickets.map(t => `
                    <tr>
                        <td><a href="#" onclick="Handlers.handleTicketRowClick('${t.ticketInterno}'); return false;">${t.ticketInterno}</a></td>
                        <td class="truncate-text" title="${t.pedido}">${t.pedido}</td>
                        <td class="truncate-text" title="${t.planilla}">${t.planilla}</td>
                        <td><span class="badge bg-secondary">${t.creadoPor}</span></td>
                        <td>
                            <select class="form-select form-select-sm" onchange="Handlers.handleQuickManageUpdate('${t.ticketInterno}', 'status', this.value)">
                                <option value="Registrado" ${t.estado === 'Registrado' ? 'selected' : ''}>Registrado</option>
                                <option value="En Progreso" ${t.estado === 'En Progreso' ? 'selected' : ''}>En Progreso</option>
                                <option value="Resuelto" ${t.estado === 'Resuelto' ? 'selected' : ''}>Resuelto</option>
                                <option value="Cerrado" ${t.estado === 'Cerrado' ? 'selected' : ''}>Cerrado</option>
                            </select>
                        </td>
                        <td>
                            <select class="form-select form-select-sm" onchange="Handlers.handleQuickManageUpdate('${t.ticketInterno}', 'priority', this.value)">
                                <option value="Normal" ${t.prioridad === 'Normal' ? 'selected' : ''}>Normal</option>
                                <option value="Urgente" ${t.prioridad === 'Urgente' ? 'selected' : ''}>Urgente</option>
                            </select>
                        </td>
                        <td>
                            <textarea class="form-control form-control-sm" rows="1" onblur="Handlers.handleQuickManageUpdate('${t.ticketInterno}', 'observations', this.value)">${t.observacionesAuditor || ''}</textarea>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-info" onclick="Handlers.handleTicketRowClick('${t.ticketInterno}')" title="Ver Detalles">
                                <i class="fas fa-eye"></i>
                            </button>
                        </td>
                    </tr>
                `).join('');
            }
            this.renderQuickManagePaginationControls();
        },

        /**
         * üÜï Renderiza los controles de paginaci√≥n para el Panel de Gesti√≥n R√°pida.
         */
        renderQuickManagePaginationControls() {
            const paginationContainer = document.getElementById('quick-manage-pagination');
            if (!paginationContainer) return;

            const { currentPage, totalPages } = state.quickManagePagination;
            let paginationHtml = `
                <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="prev">Anterior</a>
                </li>
            `;

            let startPage = Math.max(1, currentPage - 2);
            let endPage = Math.min(totalPages, currentPage + 2);

            if (startPage === 1 && endPage < totalPages) {
                endPage = Math.min(totalPages, endPage + (3 - (currentPage - startPage)));
            }
            if (endPage === totalPages && startPage > 1) {
                startPage = Math.max(1, startPage - (3 - (endPage - currentPage)));
            }

            for (let i = startPage; i <= endPage; i++) {
                paginationHtml += `
                    <li class="page-item ${i === currentPage ? 'active' : ''}">
                        <a class="page-link" href="#" data-page="${i}">${i}</a>
                    </li>
                `;
            }

            paginationHtml += `
                <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                    <a class="page-link" href="#" data-page="next">Siguiente</a>
                </li>
            `;
            paginationContainer.innerHTML = paginationHtml;
        },

        /**
         * @description Rellena el modal de detalles con la informaci√≥n de un ticket espec√≠fico.
         * @param {object} ticket - El objeto del ticket cuyos detalles se van a mostrar.
         */
        renderTicketDetailModal(ticket) {
            document.getElementById('detalle-ticket-id').textContent = ticket.ticketInterno;
            document.getElementById('detalle-pedido').textContent = ticket.pedido || 'N/A';
            document.getElementById('detalle-planilla').textContent = ticket.planilla || 'N/A';
            document.getElementById('detalle-creadoPor').textContent = ticket.creadoPor || 'N/A';
            document.getElementById('detalle-timestamp').textContent = ticket.timestamp.toLocaleString();
            document.getElementById('detalle-estado').innerHTML = `<span class="badge ${this.getBadgeClassForStatus(ticket.estado)}">${ticket.estado}</span>`;
            document.getElementById('detalle-herramienta').textContent = ticket.herramienta || 'N/A';
            document.getElementById('detalle-casoYoizen').textContent = ticket.casoYoizen || 'N/A';
            document.getElementById('detalle-idDerivacion').textContent = ticket.idDerivacion || 'N/A';
            document.getElementById('detalle-numeroTicket').textContent = ticket.numeroTicket || 'N/A';

            // üÜï Mostrar "Tomado Por"
            const tomadoPorElement = document.getElementById('detalle-tomadoPor');
            if (tomadoPorElement) {
                tomadoPorElement.textContent = ticket.tomadoPor ? `Tomado por: ${ticket.tomadoPor}` : 'No tomado por un auditor.';
            }

            const detallePrioridadSelect = document.getElementById('detalle-prioridad');
            detallePrioridadSelect.value = ticket.prioridad || 'Normal';

            const adjuntoContainer = document.getElementById('detalle-adjunto-container');
            if (ticket.adjuntoUrl && ticket.adjuntoUrl.startsWith('http')) {
                adjuntoContainer.innerHTML = `<a href="${ticket.adjuntoUrl}" target="_blank" class="btn btn-sm btn-outline-primary"><i class="fas fa-paperclip me-2"></i>Ver Archivo Adjunto</a>`;
            } else {
                adjuntoContainer.innerHTML = `<p class="text-muted fst-italic">${ticket.adjuntoUrl || 'No se adjunt√≥ archivo.'}</p>`;
            }

            const obsContainer = document.getElementById('detalle-observaciones-auditor-container');
            const obsInput = document.getElementById('detalle-observaciones-auditor');
            const saveObsBtn = document.getElementById('save-observaciones-btn');
            const prioridadContainer = document.getElementById('detalle-prioridad-container');
            const savePrioridadBtn = document.getElementById('save-prioridad-btn');
            const takeTicketBtn = document.getElementById('take-ticket-btn'); // üÜï Bot√≥n "Tomar Ticket"

            obsContainer.style.display = 'block';
            obsInput.value = ticket.observacionesAuditor || '';

            if (state.userProfile.role === 'AUDITOR' || state.userProfile.role === 'SUPERUSER') {
                obsInput.readOnly = false;
                saveObsBtn.style.display = 'block';
                saveObsBtn.onclick = () => Handlers.handleTicketObservationsUpdate(ticket.ticketInterno, obsInput.value);

                detallePrioridadSelect.disabled = false;
                savePrioridadBtn.style.display = 'block';
                savePrioridadBtn.onclick = () => Handlers.handleTicketPriorityUpdate(ticket.ticketInterno, detallePrioridadSelect.value);

                // üÜï Mostrar bot√≥n "Tomar Ticket" si el ticket no ha sido tomado o si el auditor actual lo tom√≥
                if (!ticket.tomadoPor || ticket.tomadoPor === state.userProfile.email.split('@')[0]) {
                    takeTicketBtn.style.display = 'block';
                    takeTicketBtn.textContent = ticket.tomadoPor ? 'Ya Tomado por ti' : 'Tomar Ticket';
                    takeTicketBtn.disabled = !!ticket.tomadoPor; // Deshabilitar si ya est√° tomado por el usuario actual
                } else {
                    takeTicketBtn.style.display = 'none'; // Ocultar si ya est√° tomado por otro auditor
                }

            } else {
                obsInput.readOnly = true;
                saveObsBtn.style.display = 'none';

                detallePrioridadSelect.disabled = true;
                savePrioridadBtn.style.display = 'none';
                takeTicketBtn.style.display = 'none'; // Ocultar para usuarios normales
            }

            const commentsContainer = document.getElementById('ticket-comments-list');
            const newCommentInput = document.getElementById('new-comment-text');
            const submitCommentBtn = document.getElementById('submitCommentButton');
            const alertPlaceholderComments = document.getElementById('alertPlaceholderComments');

            commentsContainer.innerHTML = '<div class="text-center text-muted fst-italic">Cargando comentarios...</div>';
            newCommentInput.value = '';
            alertPlaceholderComments.innerHTML = '';
            UI.toggleButtonSpinner(submitCommentBtn, false);

            API.runServerFunction('getTicketComments', ticket.ticketInterno,
                response => {
                    if (response.status === 'ok') {
                        state.comments[ticket.ticketInterno] = response.comments;
                        if (response.comments.length === 0) {
                            commentsContainer.innerHTML = '<div class="text-center text-muted fst-italic">No hay comentarios a√∫n.</div>';
                        } else {
                            commentsContainer.innerHTML = response.comments.map(c => `
                                <div class="comment-item mb-2 p-2 border rounded">
                                    <small class="text-muted">${c.autor} - ${new Date(c.timestamp).toLocaleString()}</small>
                                    <p class="mb-0">${c.comentario}</p>
                                </div>
                            `).join('');
                        }
                    } else {
                        commentsContainer.innerHTML = `<div class="alert alert-danger">Error al cargar comentarios: ${response.message}</div>`;
                    }
                },
                error => {
                    commentsContainer.innerHTML = `<div class="alert alert-danger">Error del servidor: ${error.message}</div>`;
                    UI.handleError(error);
                }
            );

            submitCommentBtn.onclick = () => Handlers.handleCommentSubmit(ticket.ticketInterno);

            const historyContainer = document.getElementById('ticket-history-list');
            historyContainer.innerHTML = '<div class="text-center text-muted fst-italic">Cargando historial...</div>';

            API.runServerFunction('getTicketHistory', ticket.ticketInterno,
                response => {
                    if (response.status === 'success') {
                        if (response.history.length === 0) {
                            historyContainer.innerHTML = '<div class="text-center text-muted fst-italic">No hay historial de cambios para este ticket.</div>';
                        } else {
                            historyContainer.innerHTML = response.history.map(h => `
                                <div class="history-item mb-2 p-2 border rounded">
                                    <small class="text-muted">${new Date(h.timestamp).toLocaleString()} - ${h.usuario}</small>
                                    <p class="mb-0">${h.cambio}</p>
                                </div>
                            `).join('');
                        }
                    } else {
                        historyContainer.innerHTML = `<div class="alert alert-danger">Error al cargar historial: ${response.message}</div>`;
                    }
                },
                error => {
                    historyContainer.innerHTML = `<div class="alert alert-danger">Error del servidor al cargar historial: ${error.message}</div>`;
                    UI.handleError(error);
                }
            );
        },

        /**
         * @description Calcula las m√©tricas de creaci√≥n y resoluci√≥n de tickets por usuario.
         * @returns {object} Un objeto donde cada clave es un usuario y el valor son sus m√©tricas.
         */
        calculateUserMetrics() {
            const metrics = {};
            const allTickets = state.allTicketsForStats;
            allTickets.forEach(ticket => {
                const user = ticket.creadoPor || 'Desconocido';
                if (!metrics[user]) metrics[user] = { total: 0, Resuelto: 0, 'En Progreso': 0, Registrado: 0, Cerrado: 0 };
                metrics[user].total++;
                const statusKey = ticket.estado || 'Registrado';
                if (metrics[user].hasOwnProperty(statusKey)) metrics[user][statusKey]++;
            });
            return metrics;
        },

        /**
         * @description Renderiza la tabla de m√©tricas por usuario en su modal correspondiente.
         */
        renderUserMetricsModal() {
            const metrics = this.calculateUserMetrics();
            const tbody = document.getElementById('user-metrics-table-body');
            if (!tbody) return;
            if (Object.keys(metrics).length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center text-muted fst-italic">No hay datos de m√©tricas de usuario.</td></tr>`;
            } else {
                tbody.innerHTML = Object.entries(metrics).map(([user, data]) => {
                    const rate = data.total > 0 ? ((data.Resuelto / data.total) * 100).toFixed(1) + '%' : '0%';
                    return `<tr>
                    <td class="fw-bold">${user}</td>
                    <td>${data.total}</td>
                    <td class="text-success">${data.Resuelto}</td>
                    <td class="text-warning">${data['En Progreso']}</td>
                    <td class="text-primary">${data.Registrado}</td>
                    <td>
                        <div class="progress" style="height: 20px;">
                            <div class="progress-bar bg-success" role="progressbar" style="width: ${rate};" aria-valuenow="${parseFloat(rate)}" aria-valuemin="0" aria-valuemax="100">${rate}</div>
                        </div>
                    </div>
                    </td>
                </tr>`;
                }).join('');
            }

            UI.renderQuickManagePanel();
        },

        /**
         * @description Renderiza un gr√°fico D3.js en un contenedor espec√≠fico.
         * @param {string} containerId - El ID del elemento div que contendr√° el gr√°fico.
         * @param {object} chartData - Los datos formateados para el gr√°fico.
         * @param {string} type - El tipo de gr√°fico ('line', 'donut', 'bar').
         * @param {string} title - El t√≠tulo del gr√°fico.
         */
        renderD3Chart(containerId, chartData, type, title) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            const width = container.clientWidth;
            const height = container.clientHeight > 0 ? container.clientHeight : 250;

            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // A√±adir t√≠tulo al gr√°fico
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20) // Ajustar posici√≥n del t√≠tulo
                .attr("text-anchor", "middle")
                .style("font-size", "1.3rem")
                .style("font-weight", "700")
                .style("fill", "var(--text-color)")
                .text(title);

            if (type === 'line') {
                const margin = { top: 40, right: 30, bottom: 40, left: 50 }; // Ajustar margen superior por el t√≠tulo
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .domain(chartData.labels)
                    .range([0, innerWidth])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(chartData.datasets, d => d3.max(d.data)) * 1.2])
                    .range([innerHeight, 0]);

                g.append("g")
                    .attr("transform", `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-.8em")
                    .attr("dy", ".15em")
                    .attr("transform", "rotate(-45)")
                    .style("fill", "var(--text-color)");

                g.append("g")
                    .call(d3.axisLeft(y))
                    .selectAll("text")
                    .style("fill", "var(--text-color)");

                chartData.datasets.forEach(dataset => {
                    const line = d3.line()
                        .x((d, i) => x(chartData.labels[i]) + x.bandwidth() / 2)
                        .y(d => y(d))
                        .curve(d3.curveMonotoneX);

                    g.append("path")
                        .datum(dataset.data)
                        .attr("fill", "none")
                        .attr("stroke", dataset.borderColor)
                        .attr("stroke-width", 2)
                        .attr("d", line);

                    g.selectAll(`.dot-${dataset.label.replace(/\s/g, '')}`)
                        .data(dataset.data)
                        .enter().append("circle")
                        .attr("class", `dot-${dataset.label.replace(/\s/g, '')}`)
                        .attr("cx", (d, i) => x(chartData.labels[i]) + x.bandwidth() / 2)
                        .attr("cy", d => y(d))
                        .attr("r", 4)
                        .attr("fill", dataset.borderColor)
                        .on("mouseover", function (event, d) {
                            d3.select(this).attr("r", 6);
                            const tooltip = d3.select("body").append("div")
                                .attr("class", "tooltip")
                                .style("opacity", 0);
                            tooltip.transition().duration(200).style("opacity", .9);
                            tooltip.html(`Valor: ${d}`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            d3.select(this).attr("r", 4);
                            d3.select(".tooltip").remove();
                        });
                });

                const legend = g.append("g")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", 10)
                    .attr("text-anchor", "end")
                    .selectAll("g")
                    .data(chartData.datasets)
                    .enter().append("g")
                    .attr("transform", (d, i) => `translate(0,${i * 20})`);

                legend.append("rect")
                    .attr("x", innerWidth - 19)
                    .attr("width", 19)
                    .attr("height", 19)
                    .attr("fill", d => d.borderColor);

                legend.append("text")
                    .attr("x", innerWidth - 24)
                    .attr("y", 9.5)
                    .attr("dy", "0.32em")
                    .text(d => d.label)
                    .style("fill", "var(--text-color)");

            } else if (type === 'donut') {
                const radius = Math.min(width, height) / 2 - 20;

                const g = svg.append("g")
                    .attr("transform", `translate(${width / 2},${height / 2 + 20})`); // Ajustar posici√≥n por el t√≠tulo

                const pie = d3.pie()
                    .value(d => d);

                const arc = d3.arc()
                    .innerRadius(radius * 0.6)
                    .outerRadius(radius);

                const arcs = g.selectAll("arc")
                    .data(pie(chartData.datasets[0].data))
                    .enter()
                    .append("g")
                    .attr("class", "arc");

                arcs.append("path")
                    .attr("d", arc)
                    .attr("fill", (d, i) => chartData.datasets[0].backgroundColor[i])
                    .attr("stroke", state.isDarkMode() ? '#1e293b' : 'white')
                    .style("stroke-width", "2px")
                    .on("mouseover", function (event, d) {
                        d3.select(this).transition().duration(200)
                            .attr("d", d3.arc().innerRadius(radius * 0.6).outerRadius(radius * 1.05));
                        const tooltip = d3.select("body").append("div")
                            .attr("class", "tooltip").style("opacity", 0);
                        tooltip.transition().duration(200).style("opacity", .9);
                        tooltip.html(`${chartData.labels[d.index]}: ${d.data}`) // Mostrar valor absoluto
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).transition().duration(200)
                            .attr("d", arc);
                        d3.select(".tooltip").remove();
                    });

                arcs.append("text")
                    .attr("transform", d => `translate(${arc.centroid(d)})`)
                    .attr("dy", "0.35em")
                    .text(d => `${chartData.labels[d.index]} (${d.data})`) // Mostrar valor absoluto
                    .style("font-size", "12px")
                    .style("text-anchor", "middle")
                    .style("fill", state.isDarkMode() ? 'white' : 'black');
            } else if (type === 'bar') { // üÜï L√≥gica para gr√°fico de barras
                const margin = { top: 40, right: 30, bottom: 60, left: 60 }; // M√°s margen inferior para etiquetas largas
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .domain(chartData.labels)
                    .range([0, innerWidth])
                    .padding(0.2);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(chartData.data) * 1.2])
                    .range([innerHeight, 0]);

                // Eje X
                g.append("g")
                    .attr("transform", `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-.8em")
                    .attr("dy", ".15em")
                    .attr("transform", "rotate(-45)")
                    .style("fill", "var(--text-color)");

                // Eje Y
                g.append("g")
                    .call(d3.axisLeft(y).ticks(5))
                    .selectAll("text")
                    .style("fill", "var(--text-color)");

                // Barras
                g.selectAll(".bar")
                    .data(chartData.data)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", (d, i) => x(chartData.labels[i]))
                    .attr("y", d => y(d))
                    .attr("width", x.bandwidth())
                    .attr("height", d => innerHeight - y(d))
                    .attr("fill", (d, i) => Array.isArray(chartData.backgroundColor) ? chartData.backgroundColor[i] : chartData.backgroundColor)
                    .on("mouseover", function (event, d) {
                        d3.select(this).attr("opacity", 0.8);
                        const tooltip = d3.select("body").append("div")
                            .attr("class", "tooltip")
                            .style("opacity", 0);
                        tooltip.transition().duration(200).style("opacity", .9);
                        tooltip.html(`Valor: ${d}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).attr("opacity", 1);
                        d3.select(".tooltip").remove();
                    });

                // Etiquetas de valor en las barras (opcional, si hay espacio)
                g.selectAll(".bar-label")
                    .data(chartData.data)
                    .enter().append("text")
                    .attr("class", "bar-label")
                    .attr("x", (d, i) => x(chartData.labels[i]) + x.bandwidth() / 2)
                    .attr("y", d => y(d) - 5) // Un poco por encima de la barra
                    .attr("text-anchor", "middle")
                    .style("fill", "var(--text-color)")
                    .style("font-size", "10px")
                    .text(d => d);
            }
        },

        /**
         * @description Muestra una alerta din√°mica de Bootstrap en un contenedor espec√≠fico.
         * @param {string} elementId - ID del elemento donde se insertar√° la alerta.
         * @param {string} message - El mensaje a mostrar.
         * @param {string} type - El tipo de alerta de Bootstrap (ej. 'success', 'danger').
         */
        showAlert(elementId, message, type) {
            const placeholder = document.getElementById(elementId);
            if (placeholder) {
                placeholder.innerHTML = '';
                const wrapper = document.createElement('div');
                wrapper.innerHTML = `<div class="alert alert-${type} alert-dismissible fade show" role="alert">${message}<button type="button" class="btn-close" data-bs-dismiss="alert"></button></div>`;
                placeholder.append(wrapper);
            }
        },

        /**
         * @description Alterna el estado de un bot√≥n entre activo y de carga (con spinner).
         * @param {HTMLElement} button - El elemento del bot√≥n.
         * @param {boolean} show - True para mostrar el spinner, false para mostrar el texto.
         */
        toggleButtonSpinner(button, show) {
            if (!button) return;
            button.disabled = show;
            button.querySelector('.spinner-border')?.classList.toggle('d-none', !show);
            const text = button.querySelector('.button-text');
            if (text) text.style.display = show ? 'none' : 'inline';
        },

        /**
         * @description Cambia entre modo claro y oscuro.
         */
        toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));

            if (state.currentView === 'dashboard') {
                const chartData = UI.prepareDashboardCharts(state.allTicketsForStats);
                UI.renderD3Chart('ticketsChart', chartData.activity, 'line', 'Actividad de Tickets');
                UI.renderD3Chart('ticket-status-chart', chartData.ticketStatus, 'bar', 'Distribuci√≥n de Tickets por Estado');
                UI.renderD3Chart('realtime-metrics-chart', chartData.realtimeMetrics, 'line', 'Tickets Creados (√öltimas 24h)');
            } else if (state.currentView === 'reports') {
                const chartData = UI.prepareDashboardCharts(state.allTicketsForStats);
                UI.renderD3Chart('reportsChart1', chartData.activity, 'line', 'Tendencia de Tickets');
                UI.renderD3Chart('reportsChart3', chartData.ticketsByTool, 'bar', 'Tickets por Herramienta');
            }
            const modalAuditoria = document.getElementById('modalMetricasUsuario');
            if (modalAuditoria && modalAuditoria.classList.contains('show')) {
                UI.renderQuickManagePanel();
            }
        },

        /**
         * üîß FUNCI√ìN CORREGIDA: Manejador de errores que usa el sistema de loading
         * @param {Error} error - El objeto de error.
         */
        handleError(error) {
            console.error('‚ùå Error del servidor o de la aplicaci√≥n:', error);
            LoadingManager.hide();
            UI.showAlert('global-alert-placeholder', `Error: ${error.message || 'Ocurri√≥ un error desconocido.'}`, 'danger');
        },

        /**
         * @description Funci√≥n de utilidad para obtener la clase CSS de Bootstrap correspondiente a un estado de ticket.
         * @param {string} status - El estado del ticket.
         * @returns {string} La clase CSS de la insignia (badge).
         */
        getBadgeClassForStatus(status) {
            switch (status) {
                case 'Registrado': return 'bg-primary';
                case 'En Progreso': return 'bg-warning text-dark';
                case 'Resuelto': return 'bg-success';
                case 'Cerrado': return 'bg-secondary';
                default: return 'bg-info text-dark';
            }
        },

        /**
         * @description Muestra u oculta la barra lateral (sidebar).
         * @param {boolean|null} forceState - True para forzar que se muestre, false para forzar que se oculte, null para alternar.
         */
        toggleSidebar(forceState = null) {
            const sidebar = document.querySelector('.sidebar');
            const mainContent = document.querySelector('.main-content');
            if (forceState === true) {
                sidebar.classList.remove('hidden-sidebar');
                mainContent.classList.remove('full-width-content');
            } else if (forceState === false) {
                sidebar.classList.add('hidden-sidebar');
                mainContent.classList.add('full-width-content');
            } else {
                sidebar.classList.toggle('hidden-sidebar');
                mainContent.classList.toggle('full-width-content');
            }
        },
    };
</script>